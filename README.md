# 알고리즘

## 백준 문제풀이
### 1. 유니온파인드
- 1717번: 집합의 표현
- 1976번: 여행 가자
- (완) 16562번: 친구비
- 4195번: 친구 네트워크
- 14868번: 문명 (★)
- 3197번: 백조의 호수 (★)
- 11085번: 군사 이동 (★)
- 9938번: 방 청소 (★)
- 10775번: 공항 (★)
- 15459번: Haybale Feast (★)
- 17398번: 통신망 분할 (★)
- 3780번: Corporative Network (★)

### 2. 세그먼트 트리
- (완) 11505번 : 구간 곱 구하기
- (완) 12015번: 가장 긴 증가하는 부분 수열 2
- (완) 1275번: 커피숍2
- 3006번: 터보소트
- 1280번: 나무 심기 (★)
- (완) 3653번: 영화 수집 (★)
- (완) 9345번: 디지털 비디오 디스크 (★)
- (완) 2243번: 사탕상자 (★)
- 2336번: 굉장한 학생 (★)

### 3. MST(Minimum Spanning Tree)
- (완) 1922번: 네트워크 연결
- (완) 6497번: 전력난
- (완) 1647번: 도시 분할 계획 (*)
- (완) 4386번: 별자리 만들기
- 4343번: Arctic Network
- 2887번: 행성 터널 (★)
- 1944번: 복제 로봇 (★)
- 9373번: 복도 뚫기 (★)

### 4. 위상정렬
- (완) 2623번: 음악프로그램
- 2252번: 줄 세우기
- 1766번: 문제집
- 1516번: 게임 개발
- 1005번: ACM Craft
- 9470번: Strahler 순서
- 2637번: 장난감조립 (★)
- 3665번: 최종 순위 (★)
- (완) 2529번: 부등호 (★)
- 2848번: 알고스팟어 (★)
- (완) 1948번: 임계경로 (★)

### 5. LCA(Lowest Common Ancestor)
- (완) 11438번: LCA 2
- (완) 1761번: 정점들의 거리
- (완) 3176번 : 도로 네트워크 (**) => 최대, 최소값을 계산해가면서 LCA를 구해야한다.
- 8012번: 한동이는 영업사원!
- 15480번: LCA와 쿼리 (★)
- 1396번: 크루스칼의 공 (★) : LCA + MST + Union-Find

### 6. 다익스트라
- (완) 1753번: 최단경로
- (완) 1504번: 특정한 최단 경로
- (완) 1238번: 파티
- (완) 2211번: 네트워크 복구 (★) => 최저경로를 Prev 배열로 따로 저장해서 관리
- (완) 1162번: 도로포장 (★) => 방문 횟수가 K보다 작을경우, 큐에 계속 넣어준다.
- 5719번: 거의 최단 경로 (★)
- 10217번: KCM Travel (★)
- 2958번 : 도로 네트워크
- 1916번: 최소비용 구하기
- 4485번: Obstacle Course
- 1261번: 알고스팟 (★)
- 16681번: 등산
- 15422번: Bumped!

### 7. 벨만포드
- 11657번: 타임머신
- 1738번: 골목길
- 1865번: 웜홀 (★)
- 1219번: 오민식의 고민 (★)

### 8. 플로이드와샬
- (완) 11404번: 플로이드
- (완) 11403번: 경로 찾기
- (완) 1389번: 케빈 베이컨의 6단계 법칙
- (완) 1613번: 역사
- (완) 1956번: 운동
- (완) 2458번: 키 순서 (★) : 자기 자신 앞에사람 뒤에 사람 모두 알수 있으면 순위를 알수있는 것이다.
- (완) 11562번: 백양로 브레이크 (★) : 일방통행일 경우, 반대방향에 가중치 1을 줘서 계산하면 된다.
- (완) 1507번: 궁금한 민호 (★) : k를 거쳐가는 경우가, i->j와 같을 경우, i->j는 필요없는 간선이다.
- 9205번: 맥주 마시면서 걸어가기 (★)
- 13168번: 내일로 여행 (★)
- 2610번: 회의준비 (*)

## 99. 기타
- (완) 10974 : 모든 순열
- 3020번: 개똥벌레
- 1517번: 버블 소트


## 주요 코드

### 1. 다익스트라
prev를 배열을 사용하면 최단경로 추적도 가능하다.
````java
static int[] dijkstra(int start) {
    int[] values = new int[V+1];
    int[] prevs = new int[V+1];
    for (int i=0; i<V+1; i++) {
        values[i] = MAX;
        prevs[i] = -1;
    }

    PriorityQueue<Point> queue = new PriorityQueue<>(new Comparator<Point>() {
        @Override
        public int compare(Point o1, Point o2) {
            return o1.value - o2.value;
        }
    });
    queue.add(new Point(start, 0));
    values[start] = 0;

    while (!queue.isEmpty()) {
        Point p1 = queue.poll();
        int from = p1.to;
        int value = p1.value;

        for (Point p2 : POINTS[from]) {
            int to = p2.to;
            int newValue = value + p2.value;
            if (newValue < values[to]) {
                values[to] = newValue;
                prevs[to] = from;
                queue.add(new Point(to, newValue));
            }
        }
    }
    
    return values;
}
````
